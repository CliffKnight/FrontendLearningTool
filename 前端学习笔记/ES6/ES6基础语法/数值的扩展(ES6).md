[TOC]

# 数值的扩展(ES6)

## 1. 二进制八进制表示法

ES6提供了二进制和八进制数值的新写法，分别用前缀 `0b(或0B)` 和 `0o(或0O)` 表示。

如果要将使用 `0b` 和 `0x` 的数字转换为十进制，要使用Number方法。

```js
Number('0b111'); // 7
Number('0o10'); // 8
```

## 2.  Number对象

| 方法，常量(ES6新增)     | 用法                                                         |
| :---------------------- | :----------------------------------------------------------- |
| Number.isFinite()       | 检查一个数值是否是有限的，是返回true否则返回false                                                     `区别`： isFinite()的参数如果不是数值会先调用Number方法将其转换为数值，Number.isFinite() 只对数值有限非数值一律返回false |
| Number.isNaN()          | 检查一个值是否是NaN                                                                                                                           `区别`： isNaN()的参数如果不是数值会先调用Number方法将其转换为数值，Number.isNaN() 只对数值有限非数值一律返回false |
| Number.parseInt()       | 转换为整数，以前是全局方法，现在移植到Number对象上，有利于模块化 |
| Number.parseFloat()     | 转换为浮点数，以前是全局方法，现在移植到Number对象上，有利于模块化 |
| Number.isInteger()      | 判断一个值是否为整数，在JS中整数和浮点数是同样的储存方法，所以3和3.0被视为一个值，这一点和c等语言是不同的 |
| Number.EPSILON          | 极小的常量， `Number.EPSILON // 2,220446049250313e-16`                                       `作用`：为浮点数设置一个误差范围，我们知道JS中浮点数的计算是不精确的，当误差小于某个很小的数后我们就认为计算正确 |
| Number.MAX_SAFE_INTEGER | JS能表示的最大整数=Math.pow(2,53)-1=9007199254740991                                                            `JS能正确表示的整数范围(安全范围)是-2的53次方~2的53次方，超出这个范围就无法正确表示了` 如 `Math.pow(2,53)=== Math.pow(2.53)+1  // 返回true` |
| Number.MIN_SAFE_INTEGER | JS能表示的最小整数=-Number.MAX_SAFE_INTEGER                  |
| Number.isSafeInteger()  | 判断一个整数是否在安全范围内，是返回true否则返回false        |

## 3. Math对象

| Math方法(ES6新增) | 用法                                                         |
| :---------------- | :----------------------------------------------------------- |
| Math.tunc()       | 去除一个数的小数部分，对于非数值先调用Number方法将其转换为数值，对于空值和无法截取整数的值返回Nan |
| Math.sign()       | 判断一个数是正数，负数，还是零。对于非数值，会先将其转换为数值                                 `返回值`：正数 +1  负数 -1   0返回0  -0返回-0  其他值 返回NaN |
| Math.cbrt()       | 计算一个数的立方根，非数值先转换为数值                       |
| Math.clz32()      | JS中整数用32位二进制形式表示，该方法返回一个数的32位无符号整数形式有多少个前导0 |
| Math.imul()       | 返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数 |
| Math.fround()     | 返回一个数的单精度浮点数形式                                 |
| Math.hypot()      | 返回所有参数的平方和的平方根 `Math.hypot(3,4) // 5`          |
| Math.expm1()      | `Math.expm1(x)===Math.exp(x)-1`                              |
| Math.log1p()      | `Math.log1p(x)===Math.log(1+x)` `注意` ：JS中的log实际上是数学中的ln |
| Math.log10()      | 返回以10为底x的对数，如果x小于0返回NaN                       |
| Math.log2()       | 返回以2为底x的对数，如果x小于0返回NaN                        |
| Math.sinh(x)      | 返回x的双曲正弦                                              |
| Math.cosh(x)      | 返回x的双曲余弦                                              |
| Math.tanh(x)      | 返回x的双曲正切                                              |
| Math.asinh()      | 返回x的反双曲正弦                                            |
| Math.acosh()      | 返回x的反双曲余弦                                            |
| Math.atanh()      | 返回x的反双曲正切                                            |
| Math.signbit()    | 判断一个数的符号位是否已经设置，正数的符号位为0，符号位没有设置，负数的符号位为1，符号位已经设置。                                                                                                               `返回值`：如果参数是NaN，返回false      如果参数是-0，返回true     如果参数是负数，返回true       如果参数是正数，返回false     其它情况返回false |

## 4. 指数运算符

ES2016新增了一个指数运算符(**)。

```js
2 ** 2 // 4
2 ** 3 // 8
```

指数运算符可以与等号结合，形成一个新的赋值运算符(**=)。

```js
let a = 3;
a **= 2 // 9
//等同于
let a = 3;
a = a ** 2 // 9 
```

## 5. Integer 数据类型

### 5.1 简介

JavaScript所有数字都保存成64为浮点数，这决定了整数的精确程度只能到52个二进制位。

大于这个范围的整数，JavaScript是无法精确表示的，这使得JavaScript不适合进行科学和金融方面的精确计算。

现有一个提案，引入了新的数据类型 `Integer` 来解决这个问题。

**Integer类型的数据只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。**

为了与Number类型区别，Integer类型的数据必须使用后缀n来表示。

```js
1n + 2n // 3n 
```

二进制，八进制，十六进制的表示法都要加上后缀n。

```js
0b1101n // 二进制 
0o777n // 八进制
0xFFn // 十六进制
```

对于Integer类型的数据，typeof运算符将返回integer。

JS还提供了Integer队形，用来生成Integer类型的数值。

```js
Integer(123) // 123n
```

但是注意不能生成Integer类型的对象，下面这样生成Integer对象的代码会报错。

```js
new Integer() // TypeError
```

### 5.2 运算

在数学运算方面，Interger类型的+，-，*和 **这四个二元运算符与Number类型的行为一致。

除法运算 `/` 会舍去小数部分，返回一个整数。

```js
9n/5n // 1n
```

下面两种运算符用在Integer中会报错：

1. 不带符号的右移运算符>>>

   不带符号的右移运算符要求最高位补0，但是Integer类型没有最高位，导致这个运算符没有意义。

2. 一元的求正运算符+

   一元运算符+在asm.js里面子那个是返回Number类型或报错。

Integer类型与Number类型不能混合运算。

```js
1n + 1 // 报错
```

这是因为无论返回值是哪一种类型都会丢失信息，比如

``` js
(2n ** 53n + 1n) + 0.5
```

如果返回 Integer 类型，那么0.5会被舍去

如果返回 Number 类型，那么超出了安全范围，会超过53为精确数字，精度下降。

相等运算符(==)会改变数据类型，因此不能混合使用。

```js
1n == 1 // TypeError
```

精确相等运算符 (===) 不会改变数据类型，因此可以混合使用。

```js]
1n === 1 // false
```

​	