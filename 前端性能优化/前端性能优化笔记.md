# 前端性能优化

## 1. 概述

前端性能优化点涉及构建层面，浏览器渲染层面，网络层面，服务端层面。

涉及功能主要有

- 资源的合并与压缩
- 图片编解码原理和类型选择
- 浏览器渲染机制
- 懒加载，预加载
- 浏览器存储
- 缓存机制
- PWA
- Vue-SSR

技术栈主要用到 chrome 浏览器中的 performance 和 layer 调试。

课程的核心是讲前端性能优化的原理，如何与真实业务场景结合，理论结合实践，还要进行量化分析，数据说明一切。

课程主要分为基础优化（第1-3章），进阶优化（第4-7章），结合服务端优化（第8章），回顾总结（第9章）四个部分。

## 2. 资源的合并与压缩

### 2.1 http 清求的过程及潜在的性能优化点

**目标**

1）理解减少http请求数量和减少请求资源大小两个优化要点

​	减少 http 请求数量 -- 资源合并     减少请求资源的大小 -- 资源压缩

2）掌握压缩与合并的原理

3）掌握通过在线网站和fis3两种压缩与合并的方法

**Web 前端和原生应用有什么区别？**

Web 前端本质上是一种 GUI（图形用户接口，说白了就是能让用户看到的界面）软件，可以借鉴其它 GUI 系统架构设计方法，如原生应用，但是和它们又有一些不同。

原生应用是 CS（客户端服务器） 架构，开发者将开发完的代码打包成安装包发布到各大应用商店，用户通过下载获得。在客户端运行时，许多访问的资源在本地都是有的，因此原生应用有一个很大的优势就是离线也可以使用。

Web前端是 BS（浏览器客户端）架构，开发者开发完代码打包后发布到远程服务器 webServer 以及远程 CDN 上，用户打开浏览器输入特定网址才会向服务器发出请求，通过 http 请求获取到资源，这个过程是增量式的，请求什么就获得什么，而不像原生应用不论用不用到先把资源下载到本地，因此如果能够快速地获取到请求的资源那么用户的体验就会比较好，这个时候性能优化就很重要。

**浏览器一个请求从发送到返回都经历了什么？**

通过思考这一整个过程来思考那些步骤是可以进行性能优化的。

深入理解http 请求的过程是前端性能优化的核心。

### 2.2 html 压缩

HTML 代码压缩就是压缩在文本文件中有意义但是在 HTML 中不显示的字符，包括空格，制表符，换行符等，还有一些其它意义的字符，如HTML注释也可以被压缩。

![1584761120964](https://raw.githubusercontent.com/happyCoding1024/image-hosting/master/img/html压缩.png)

html 压缩效果

![1584761406802](https://raw.githubusercontent.com/happyCoding1024/image-hosting/master/img/html压缩效果.png)

看似 html 压缩并不明显，但是只要是有压缩对一些公司都是有需求的。

**如何进行 html 压缩**

1）使用在线网站进行压缩

​	现代化前端很少会使用，因为现在都是使用 webpack 等构建工具进行构建的。

2）node.js 提供了 html-minifier 工具

​	一方面在构建方面另一方面在服务端，node.js 目前主要有这两种用途。

3）后端模板引擎渲染压缩

### 2.3 CSS 与 JS 压缩

**CSS 压缩**

无效代码删除

css 语义合并

**如何进行 css 压缩**

1）使用在线网站

2）使用 html-minifier 对 html 中的 css 进行压缩

3）使用 clean-css 对 css 进行压缩

**JS 压缩**

- 无效字符的删除（回车，制表符等）
- 剔除注释
- 代码语义的缩减和优化
- 代码保护（因为我们最终要将代码发布到线上，通过压缩使JS代码可读性变差，不利于别人看清代码的逻辑）

**如何进行 JS 压缩和混乱**

1）使用在线网站进行压缩

2）使用 html-minifier 对 html 中的 js 进行压缩

3）使用 uglifyjs2 对 js 进行压缩

JS 压缩和 CSS 压缩比 HTML 压缩效果要好很多，所以对于一些公司，HTML 压缩可有可无，但是 CSS 压缩和 JS 压缩一般都会有。

### 2.4 文件合并

将几个文件合并到一起，只请求一次，优点就是减少了 http 请求的次数。

缺点主要有两个：

1）首屏渲染

将文件合并之后，一次请求的文件是比较大的，请求的时间会比较长，首屏渲染会比较慢。

2）缓存失效

我们知道浏览器是有缓存的，每个文件的 url 后面都有一个 MD5 戳，当再次请求相同的文件时并且文件的内容没有变化时，就不会再次请求这个文件了，而是直接使用缓存中的。但是当进行文件合并之后，就不会使用缓存中的了。

**那么怎样合理地使用文件合并呢？**

1）公共库合并

​	库文件一般只引用一次而且一般也不会变化，可以进行打包合并。

2）不同页面合并

​	主要是针对现在的单页面应用，每个页面用到的 js 文件时不同的，将每个页面用到的 js 进行分别	打包，这样在进入到某个页面时会比较快。

**如何进行文件合并**

1）使用在线网站

2）使用 node.js（构建工具，如 webpack，只需要配置 entry 和 output，将这个 entry 下的所有文件会合并到一起，输出到 output 指定的文件中）实现文件合并。

## 3. 图片相关的优化

**目标**

- 理解图片相关的优化的核心概念
- 结合 facebook 和淘宝移动首页案例分析
- 掌握通过在线网站和 fis3 两种实现图片相关的一些优化

### 3.1 一张 jpg 图片的解析过程

![jpg图片的解析过程](https://raw.githubusercontent.com/happyCoding1024/image-hosting/master/img/jpg图片的解析过程.png)

### 3.2 png8/png24/png32 之间的区别

- png8 ---- 256色，支持透明（文件最小）
- png24 ---- 2^24色，不支持透明
- png32 ---- 2^24色，支持透明

png8 只有 256 种颜色，用这 256 种颜色来表示图片。

### 3.3 不同格式图片常用的业务场景

- jpg 有损压缩，压缩率高，不支持透明，大部分不需要透明图片的业务场景
- png 支持透明，浏览器兼容性好，大部分需要透明图片的业务场景
- webp 压缩程度更好，在 ios webview 中有兼容性问题，安卓全部（因为这种格式压缩率更高）
- svg 矢量图，代码内嵌，相对较小，图片样式相对简单的场景（如iconfont）

jpg 相对 png 压缩率更高，图片更小。webp 压缩率更高，安卓上能用尽量用。

### 3.4 图片压缩的几种方法

> 常用的图片压缩网站：[tinypng]( https://tinypng.com/ )

针对真实图片情况，舍弃一些相对无关紧要的色彩信息。

**雪碧图**

> 雪碧图网站 [spritecow](www.spritecow.com)，将雪碧图导入之后选中其中一个图在下面立刻会出现样式。

将一些图片整合到一张单独的图片中，这样可以减少 http 请求数量，但是由于整合后图片比较大，请求时加载地比较慢，影响页面的显示。

所以雪碧图的大小要适宜。

**简述一下使用雪碧图的过程**

通过 PS 制作雪碧图，以背景的方式引入，设置背景为 no-repeat，设置元素宽度和高度和雪碧图中某个图片差不多大，设置背景的位置background-position 来移动背景使得想展示的图片刚好可以展示出来。注意 background-position 的 x 和 y 值都是负的。

**Image inline**

将图片转换为 base64 的以文本的形式内嵌到 html 中，这样可以减少 http 的请求数量，但是会使得请求的 html 文件变大。所以，图片不能太大，当图片很小时，这种方法是非常适合的。

**使用矢量图**

通过 svg 标签提供的属性绘制一些曲线等比较简单的图形，使用 svg 最常见的应用就是 iconfont。（原来 iconfont 就是svg标签绘制的）

**在安卓下使用 webp**

webp 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，同时具备无损和有损的压缩模式。

## 4 CSS 与 JS 的加载与执行

**目标**

1）理解浏览器端 html，css，js 的加载过程

2）结合 chrome 的能力学习掌握 css， js 加载过程中的优化点

3）通过案例分析和实战演练深入理解学习的优化点

**一个网站在浏览器端是如何进行渲染的呢？**

![html页面加载过程.png](https://images.cnblogs.com/cnblogs_com/zhangguicheng/1682529/o_200327145017html页面加载过程.png) 

假设我们输入 `www.baidu.com`，百度的服务器会返回给我们一个 html 文件，html 文件按照从上到下的顺序依次解析每个标签，遇到 link，script 等需要请求外部资源的标签会去请求资源，请求到 CSS 文件和 JS文件之后，CSS 会逐渐生成 CSSOM 树，JS 会进行一些逻辑处理，最终DOM 树和 CSSOM 树结合起来生成 RederTree 之后才会在页面上进行渲染（注意生成 DOM 树之后并不会立即进行渲染需要和CSSOM树结合之后才会渲染），然后会进行布局和绘制。

如何在这个过程中找到可以优化点是重点。

### 4.2 HTML 渲染过程中一些特点

1）顺序执行，并发加载

HTML 是按顺序依次向下解析执行的，在执行的过程中一般会引入许多 js， css 等外部资源，这些资源就会被并发加载。**这里需要注意能优化的一点是：**浏览器对于单个域名的并发度是有限的，例如这些外部资源全都在同一个 CDN 上，这样可能对有些资源可能做不到并发加载。解决方法是多设置 CDN 域名，例如设置四个CDN域名。

2）是否阻塞

3）依赖关系

4）引入方式

​	link 引入还是 import 引入，两者之间有什么区别，怎样引入是	最优的。

### 4.3 顺序执行和并发加载

HTML 是按顺序依次向下进行词法分析的，在执行的过程中一般会引入许多 js， css 等外部资源，这些资源就会被并发加载。**这里需要注意能优化的一点是：**浏览器对于单个域名的并发度是有限的，例如这些外部资源全都在同一个 CDN 上，这样可能对有些资源可能做不到并发加载。解决方法是多设置 CDN 域名，例如设置四个CDN域名。

### 4.4 css 阻塞和 js 阻塞

**CSS 阻塞**

1）在 head 中通过 link 标签引入的 CSS 会阻塞页面的渲染，只有当生成 CSS 树之后，页面才会被继续渲染，因此展示的页面一定是带有样式的。我们也比较推荐这种引入 CSS 的方式。

2）CSS 阻塞 JS 执行，CSS 加载完成之前会阻塞 JS 的执行。是不是渲染和 JS 执行共用一个进程的原因？

3）CSS 不阻塞外部 JS 资源的加载但是会阻塞 JS 的执行。

可以这样来理解，JS 执行可能会操作 DOM 并且改变其中的样式，但是 JS 执行时操作的一些属性或样式可能是正在加载执行的 CSS 新增加的，如果 CSS 还没有加载完， JS 就执行的话，有些属性都还没有，JS 就执行了，这显然是不符合逻辑的，所以需要 CSS 加载执行完后再去执行 JS。

**JS 阻塞**

1）直接引入的 JS 阻塞页面的渲染

直接通过script（没有加 async，defer 属性） 引入的 JS 会阻塞页面的执行。这在逻辑上也很容易理解，如果 JS 操作的 DOM 在页面上还没有加载完成就开始操作就会出问题，还有如果 JS 操作的 DOM 在页面上的属性发生了变化，JS 还是按之前的属性进行逻辑处理，也有可能会出问题。因此将 JS 放到最后面(body 的最后面)是最佳的选择。即使加了 async 和 defer 属性之后会让页面加载完后之后再去执行，但是为保险起见还是将 JS 放在 body 最后最稳妥。



**TODO**：更新中







