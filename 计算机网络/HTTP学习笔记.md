## 1. 概述

协议定义了发送方如何发送数据，接收方如何接收数据，如果没有协议那么发送方和接收方就不知道应该怎样发送数据，怎样接收数据，实际上协议提供了一套规范。

总结来说就是 http 很重要。

输入 url 后 http 在各个节点发挥的作用

![](https://raw.githubusercontent.com/happyCoding1024/image-hosting/master/img/20200114 http在一次请求中的作用.png)



## 第2章 HTTP协议基础及发展历史

### 2. 1 网络协议分层

网络五层模型

![](https://raw.githubusercontent.com/happyCoding1024/image-hosting/master/img/20200114网络五层模型.png)

物理层的主要作用是定义物理设备如何传输数据。

数据链路层在通信的实体间建立数据链路连接。

网络层为数据在结点之间传输建立逻辑链路。

传输层向用户提供了端到端的服务。

传输层向高层屏蔽了下层数据通信的细节。

应用层为应用软件提供了很多服务，例如我们想发送一个 http 请求，有 GET，POST 方法供我们使用，这些都是应用层提供给我们的。

构建于 TCP 协议之上，屏蔽网络传输的相关细节，也就是说不需要去关心数据在网络中是怎样进行传输的。

### 2.2 HTTP 协议的发展历史

**HTTP/0.9** 

只有一个命令 GET，没有 HEADER 等描述数据的信息。

HTTP1.1 及以后的版本里同一TCP 连接里面可以发送多条 http 请求，之前是不能这样做的。

**HTTP/1.0**

增加了很多命令，如 POST，PUT 等，增加了 status code 和 header，多字符集支持，多部分发送，权限，缓存等。

**HTTP/1.1（现在用的最多）**

支持了持久连接，在之前的版本中一个 http 请求就要在客户端和服务器之间创建一条  TCP 连接，在服务器将内容返回之后这个连接就关闭了，这个成本是相对比较高的，因为建立一个 TCP 连接是消耗比较高的。HTTP/1.1 里面可以实现建立一条 TCP 连接发送完一次请求并且接收到数据之后并不会立刻关闭连接。

增加了 host 和其它一些命令，host 可以使得在一台服务器上可以跑多个 web 服务(例如，一个 Java服务，一个 Node.js 服务等)。客户端可以请求到这条服务器之后还可以再去请求哪一个软件服务。

**HTTP2（将来的趋势）**

所有数据以二进制传输，在 HTTP1.1 里面大部分数据是通过字符串传输的。

同一个连接里面发送多个请求不再需要按照顺序来，例如可以将处理时间短的请求先进行处理返回。

头信息压缩以及推送等提高效率的功能，因为每次请求的时候都是需要发送 http 报文，报文的头部有很多字符串比较占用带宽，可以通过头信息压缩减少带宽占用量。

推送，服务端是可以主动发送数据给客户端的。

### 2.3 TCP 三次握手

![](https://raw.githubusercontent.com/happyCoding1024/image-hosting/master/img/TCP三次握手谢希仁.jpg)

>SYN(Synchronize Sequence Numbers ) 同步序列编号，同步位

**请简述 TCP 三次握手的过程 **

服务端最开始的时候处于 LISTEN 状态(在 Node.js 中创建一个 web 服务器后会通过 http.listen 监听一个端口)准备接收客户端的连接请求。

1）服务端我要和你建立连接，这是我的请求报文

客户端发起连接请求，请求报文中会发送一个 同步位 SYN = 1 和一个序列号 seq = x(这个序列号是随便取的)，此时客户端进入 SYN-SENT(同步已发送阶段)。

2）好的，我已经接收到你的请求报文了，但是等你接收到我的确认报文后必须再给我发一次确认报文，这个时候我再开启服务

服务端在接收到客户端的连接请求后，如果同意建立连接，则会返回一个确认报文，确认报文中含有一个 ack = x + 1，和一个序列号 seq =  y，此时服务端进入 SYN-RCVD(同步收到) 状态。

3）好的，我收到你的确认报文了，我又向你发送了确认报文

客户端在收到服务端的确认报文后，还要再向服务端给出确认，确认报文中含有一个序列号 seq=x+1（可以这样理解，因为不需要服务端再向客户端发送 ack 了，所以也就不需要再建立一个新的 seq 了，因为 ack 就是 seq + 1，这里就这样理解就好了在面试的时候不要说出来）和一个 ack = y + 1。此时 TCP 连接已经建立，客户端的状态变为 ESTABLISHED 状态。

服务端接收到客户端的确认报文后，也进入 ESTABLISHED 状态。

**为什么需要三次握手**

这是为了防止网络延时导致的已失效的连接请求报文突然又传送到了服务端，服务端发送了确认报文给客户端，但是此时客户端并没有发送连接请求，因此不会理睬服务端发来的确认报文，但是服务端这个时候认为已经建立好了连接所以开启服务准备接收客户端的数据。

下面再详细说明一下，如果只有两次握手，考虑下面一种情况，客户端发送完一个报文之后并没有丢失但是由于网络延时的原因很久也没有发送到服务端，客户端由于长时间没有收到服务端的确认报文，因此就把这条连接给关闭了。但是这个时候那个经历了网络延时的请求报文现在又发送到了服务端，服务端在接收到请求报文之后就会将确认报文再发送到客户端，但是此时由于客户端已经关闭了连接，所以也不会理睬这次服务端发送来的确认报文，但是如果只有两次握手就建立连接的话，这个时候服务端认为已经建立了连接了所以就开启了服务准备接收客户端的数据请求，但是客户端并不会发送数据请求，所以服务端的资源就被浪费了。

如果这个时候采用了三次握手，当经历了网络延时的请求到达服务端之后，服务端将确认报文发送到客户端，客户端并不会理睬这个报文，因此也不会再给服务端发送确认报文，服务端没有接收到客户端的确认报文因此也不会开启服务。

**TCP 释放连接的四次挥手**

![TCP四次挥手谢希仁.png](https://raw.githubusercontent.com/happyCoding1024/image-hosting/master/img/TCP四次挥手谢希仁.png)

在释放连接之前，客户端和服务端都处于 ESTABLISHED 的状态。

1）服务端，我已经没有数据要发送给你了，我现在申请释放连接，这是我的请求报文，我不再向你发送数据了，但是你还可以给我发送数据哦。

客户端向服务端发送要求释放连接的报文，报文中含有 FIN = 1，序列号 seq = u（注意这个 u 并不是随便取的，而是前面向服务端传送的数据的最后一个字节的序列号加1），此时客户端进入 FIN-WAIT-1（终止等待 1） 状态。

2）好的，客户端，我已经收到你的请求报文了，我向你发送了确认报文。

服务端在接收到客户端发送来的请求报文后，给客户端发送确认报文，确认报文中包括 ack = u + 1，序列号 seq = v（这个序列号也不是随便取的，而是等于服务端向客户端发送的数据的最后一个字节的序列号加 1），此时服务端处于 CLOSE-WAIT（关闭等待） 状态，客户端在收到确认报文后就处于 FIN-WAIT2（终止等待2）状态。

3）客户端，稍等一下，我问一下应用进程还有没有数据要发送给你，如果没有的话，我马上发送释放连接的报文给你，如果有的话我就先把数据发送给你，等数据发送完了，然后我就会把释放连接的报文发送给你

服务端在接收到客户端想要释放连接的请求之后，在第二步发送完确认报文后，紧接着会去询问应用进程是不是还有数据需要发送给客户端，如果有的话现在还可以发，虽然它已经不能给我们发数据了，但是它还是可以接收我们发送的数据的。当询问应用进程之后如果没有需要向客户端发送的数据，那么马上将释放连接的报文发送给客户端，如果还有需要向客户端发送的数据，那么就会进行发送，当发送完数据后就会向客户端发送一个释放连接的报文。报文中含有一个终止位 FIN = 1，还有一个序列号 seq = w （注意由于序列号是发送数据的最后一个字节的序号加1，因为此时有可能还是会向客户端发送数据的，所以此时的序列号有可能并不是之前的 u ，所以这里用了一个 w）还有一个 ack = u + 1。此时服务端进入 LAST-ACK（最后确认）状态。

4）好的，我已经接收到你发送给我的确认报文和数据了，现在我要给你发送确认报文，接收到我的确认报文你就可以释放连接了。但是我还不能马上释放连接，我还要等 2MSL 时间之后才能释放连接。

客户端在接收到释放连接的报文后，又向服务端发送了确认报文，在确认报文中 ACK = 1, ack = w + 1，序列号 seq = u +1（因为客户端已经不向服务端发送数据了所以 seq 并没有变化）。此时客户端进入 TIME-WAIT （时间等待）状态。注意此时服务端在接收到客户端传递过去的确认报文之后就会进入 CLOSED（关闭）状态，但是客户端还不行，它需要等待 2MSL（最长报文寿命）之后，客户端才进入 CLOSED 状态。

**为什么要等到 2MSL 之后才能使客户端进入 CLOSED（关闭）状态呢？**

第一，如果客户端发送给服务端的确认报文由于网络原因并没有传送到服务端，这个时候服务端就会触发超时重传机制，再次发送释放连接的报文，在客户端接收到这个释放连接的报文之后就会再次发送一次确认报文给服务端，而且此时重新启动 2MSL 计时器。如果客户端在发送完确认报文之后马上就进入 CLOSED（关闭）状态，那么就不会接收到服务端超时重传的释放连接的报文。

第二，在上述过程中有可能会出现有些报文由于网络延迟的原因导致长时间在网络中滞留从而影响下一次连接。有了 2MSL 后，在客户端发送完最后一次确认报文再经过 2MSL 的时间，在本连接中产生的所有报文都将从网络上消失，这样就不会对下一次连接产生任何的影响。

### 2.4 URI，URL 和 URN

**URI**（Uniform Resource Identifier）统一资源标志符

表示网络上的某个资源，它有两种表示形式，一种 url，它是通过资源的位置的位置来定位资源，通过资源的位置来找到这个资源，一旦资源的位置变了就找不到这个资源了；还有一种是 urn，它是通过给资源一个特定的名字来定位资源，通过资源的名字就可以找到这个资源，即使资源的位置发生了变化也可以找到那个资源。

**URL**（Uniform Resource Locator）统一资源定位符

用来定位网络上某个资源，url 就是这个资源的地址，通过这个 url 就可以找到这个资源。

`http://user:pass@host.com:80/path?query=string#hash`

`http` 协议的类型，还有如 ftp 等。

`user:pass` 用户名和密码，如果你访问的那个资源需要有特定的身份，这里的用户名和密码是用来做验证时使用，现在几乎不会采用这种方式了，因为在 url 中直接出现用户名和密码太不安全了。

`@host.com` 域名，表示一台服务器的地址，互联网中定位一台服务器是利用 IP 地址，域名经过 DNS 可以解析成 IP 地址。

`80` 端口号，表示一种服务，在经过 DNS 解析后已经找到了一台服务器，但是这台服务器上有很多服务，如 QQ，微信，百度等，端口就指定了你要访问哪种服务。

`/path` 我们一般称之为路由，定位到具体的某个资源，写法和 Linux 上路径的写法基本上是一样的。

`?query=-string` 参数

`#hash` url 中通过 #hash 前面的部分定位到了一个文档，但是这个文档很大，一次返回太大了没有必要，用户只想看其中的某个段落，#hash 就是表示文档中的某个片段。现在 web 开发中一般是用来做锚点定位的工具。

> url 就是用来定位网上的某个资源的，从 url 的各个部分可以看出，从左到右(参数之前)每个部分表示的范围是越来越小的。

**URN**

URN（Uniform Resource Name）统一资源名，通过给资源一个特定的名字来定位资源，通过资源的名字就可以找到这个资源，即使资源的位置发生了变化也可以找到那个资源。URN 仍然处于试验阶段，还未大范围使用。

> 现在所使用的 URI 都是 URL 的形式，URN 的形式使用的比较少，所以现在一般说到 URI 指的也就是 URL。

### 2.5 HTTP 报文格式

HTTP 报文包含起始行(start line)，首部(header)和可选的包含数据的主体(body)三个部分。HTTP 报文有两种，请求报文和响应报文。

起始行下面紧挨着首部，注意首部和主体之间是有一个空行的。

**请求报文的格式**

```bash
<method> <request url> <version>
<headers>

<entity-body>
```

- 起始行

  说明了要向服务器做些什么。

  `method`，请求的方法，如 GET(向服务器请求某个资源)，POST(用于向服务器上发送数据)，HEAD(与GET类似但是只返回首部不返回主体)，PUT(注意它和POST的区别，它是用于向服务器上资源(如文件)中存储数据)。

  > 有一点要说明的是这里仅仅是一个规范，具体怎样实现还是服务端说了算，例如浏览器发送了一个 POST 方法，服务端完全可以将其当作 GET 方法来处理，但是这并不推荐。

  `request url` 客户端向服务器请求的资源的地址

  `version` 请求报文所使用的 HTTP 版本号，格式为 `HTTP/主要版本号.子版本号`，如 HTTP/1.1

- 首部(header)

  里面可以有内容也可以没有内容，内容的格式为 `名字:[空格]值` 每条内容占一行。注意最后一条内容后也要跟一个空行。

- 主体（body）(可能没有)

  主体部分是由任意数据组成的数据块。有可能没有主体部分，就算没有主体部分，首部中最后一条内容的后面也是有一个空行的。

**响应报文的格式**

```bash
<version> <status> <reason-phrase>
<headers>

<entity-body>
```

和请求报文相比只有起始行的格式有所不同。

`status`  状态码，在请求报文中的方法使用来告诉服务器要做什么事情，在响应报文中的状态码是用来告诉客户端发生了什么事情，处理的结果是怎样的(成功还是失败等)，常见的状态码及含义必须滚瓜烂熟。

`reason-phase` 原因短语，原因短语是状态码的可读版本，也就是对状态码做了一些解释。

**HTTP 方法**

用于定义对资源的操作。具体内容见 《HTTP 权威指南》P56

**HTTP 状态码**

定义服务器对请求的处理结果。具体内容见 《HTTP 权威指南》P62

记住一个好的 HTTP 服务是可以通过返回给客户端的状态码来判断出此次请求的结果是什么的，也就是说在写 web 服务端程序的时候不能只知道返回 200 或 404 等，一定要根据此次请求的具体结果来返回最合适的状态码给客户端。

### 2.6 创建一个简单的 web 服务

```js
const http = require('http')

http.createServer(function (request, response) {
  console.log('request come', request.url)
  response.end('123');
}).listen(8888, () => {
  console.log('listening')
})
```



## 3. HTTP各种特性总览

### 3.1 认识 HTTP 客户端

只要是实现了能发送一个 HTTP 请求的工具就可以称之为是一个 HTTP 客户端。

最常见的 HTTP 客户端就是浏览器

curl 也是一个 HTTP 客户端，它也可以发送一个 http 请求，也能接收 http 请求，只是它不能将服务端返回的内容渲染出来供用户查看而已。

```bash
curl baidu.com
```

![](https://raw.githubusercontent.com/happyCoding1024/image-hosting/master/img/20200115curl baidu.com.png)

```bash
curl www.baidu.com
```

![](https://raw.githubusercontent.com/happyCoding1024/image-hosting/master/img/20200115curl www.baidu.com.png)

```bash
## 查看对www.baidu.com发送http请求时的一些信息
curl -v www.baidu.com
```

### 3.2 CORS 跨域请求的限制与解决

用 Node.js 创建两个服务器

服务器 1 (端口号 8888)

```js
const http = require('http')
const fs = require('fs')

http.createServer(function (request, response) {
  console.log('request come', request.url)
  // 必须要设置为utf8格式，因为要读取的是test.html中的字符串,如果不设置那么就会默认读取二进制数据。
  const html = fs.readFileSync('test.html', 'utf8')
  response.writeHead(200, {
     'Content-Type': 'text/plain'
  })
  response.end(html)
}).listen(8888, () => {
  console.log('listening 8888')
})

```



更新中...