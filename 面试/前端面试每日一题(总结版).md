[TOC]

# 前端面试每日一题(总结版)

## 2020年4月20日(typeof能判断出哪些数据类型？)

typeof能判断出哪些数据类型？
typeof能直接判断出 Number，String，Boolean，undefined，Symbol
typeof(null)返回 object，判断数组和对象返回 object，判断函数返回 function 

## 2020年4月21日 (CSS 中盒模型有几种，有什么不同？)

CSS 中盒模型有几种，有什么不同？
CSS 盒模型分为 W3C 标准盒模型和 IE 模型，W3C 标准盒模型中有元素的宽度 width 还有 border，padding， margin，其中 content 的高度和宽度不包含 padding 和 border。
IE 盒模型中也有这几种属性，但是 content 包含 padding 和 margin。  

## 2020年4月22日 (new 操作符)

 使用 new 创建对象时，new 运算符做了哪些事？

1. 创建一个新对象
2. 将构造函数的作用域赋给新对象（this 就指向了这个新对象）
3. 执行构造函数中的代码（初始化对象）
4. 返回新对象 

## 2020年4月23日(值类型和引用类型的区别)

值类型和引用类型的区别？

值类型是不可变的数据类型，例如 `let a = 10;` 在内存中的执行过程是先创建一块内存空间存储 10，然后再令 a 指向这块内存空间。如果这时候令 `a=20;` 会在内存中再开辟一段内存空间里面存放 20，然后将 a 指向这段内存空间，之前的那个内存空间会被销毁。所以值类型是不可变的，要想改变必须将之前的销毁然后创建新的内存空间。

引用类型是可变的数据类型，例如 `obj = { x: 1}` 在内存中 obj 中存放的是 `{ x: 1 }` 这个对象的地址，这个对象是在堆中存储的，通过 `obj.x=3` 改变对象的属性，这个时候并不会将之前的对象销毁，因此引用类型是可变的数据类型。  

## 2020 年4月24日

注意 `<!DOCTYPE>` 并不是 HTML 标签。

总结来说有这两个作用：

1）声明文档的类型，

2）告诉浏览器应该以什么样的标准解析这个文档

浏览器有两个模式，怪异模式和标准模式，声明 `<!DOCTYPE html>` 作用就是告诉浏览器你即将要处理的是 HTML 文档，并且在渲染文档时要按照标准模式的方式。

**MDN 解释**

 在[HTML](https://developer.mozilla.org/en-US/docs/Glossary/HTML)中，文档类型声明是必要的。所有的文档的头部，你都将会看到"` <!DOCTYPE html> `" 的身影。这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“[怪异模式(兼容模式)](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode)”的渲染模式。“`` <!DOCTYPE html> ``" 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。 

## 2020年4月25日

语义化标签的理解

按照字面意思理解就是有语义的标签，要做到用最合适的标签做最合适的事，例如要做一个导航栏，要用 Nav 而不是 div。

使用语义化标签有很多好处：

开发者看到文档后能够做到见名知义，有利于团队维护和开发。

能让页面呈现清晰的结构，机器更容易理解，有利于爬虫和搜索引擎的抓取（SEO的优化）

CSS 选择器优先级

！importtant 优先级最高  > 内联样式  >  ID 选择器  > 类，属性，伪类  >  元素，伪元素    

注意点：不会进位，一万个类选择器也抵不上一个id选择器，相同权重，后写的生效。

## 2020年4月26日

new 运算符的底层代码实现

```js
// func 为传入的构造函数
const new2 = fucntion (func) {
  const o = Object.create(func.prototype);
  const k = func.call(o);
	return k === 'object' ? k : o;
}
```

上面这种写法没有考虑带参数的情况。

## 2020年4月27日

今天的每日一题和大家分享一下 CSS 对于选择器的解析顺序。

以一段代码为例：

```css
body div .hello {
  color: #ccc;
}
```

按照我们正常的思维是浏览器会选取寻找 body，然后再去找 body 下的 div，然后再去找 div 下的 .hello 类。但是浏览器与这个过程正好相反，它会先去找到 .hello 这个类，然后再去验证它有一个父元素是 div，然后 div 再验证它是否有一个父元素是 body。

之所以按照这样的流程是出于性能的考虑，如果是第一种方式，找 body 下的 div 时有可能有特别多的 div，然后再在这些 div 中寻找 .hello 类时是非常耗时的。

## 2020 年4月28日

今天和大家分享一下 CSS 中清除浮动常用的两种方法，学累了就来看看吧。

CSS 清除浮动

1. 父元素触发 BFC（例如可以采用 overflow：hidden 使父元素触发 BFC）

2. 利用伪元素，给父元素的最后面添加一个伪元素，令伪元素 clear: both，这样就会使得左右两边都没有浮动元素，又因为它是父元素的最下面的一个元素，所以它只能在父元素的最下面并且左右都没有浮动元素，这样浮动元素就在它的上面，父元素就不会发生告诉塌陷了。

   代码示例：

   ```js
   父元素::after {
     content: '';
     clear: both; /* 使左右两边没有浮动元素 */
     display: block;
     visibility: hidden;
     height: 0;
   }
   ```

## 2020年4月29日

今天和大家来一起学习一下 JavaScript 事件循环机制中的 任务队列。

任务队列分为两种，一种是micro task，另一种是 macro-task。

macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。 

micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性) 

优先级： micro-task > macro-task； 

推荐给大家一个视频，生动形象。  两分钟了解 JavaScript EventLoop   https://www.bilibili.com/video/BV1kf4y1U7Ln 

## 2020年4月30日

今天和大家一起来学习一下面试中经常问的 GET 和 POST 的区别，主要有以下几点。

1）GET 在浏览器回退时是不会再次发送 GET 请求的，POST 会再次发送请求

2）GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置（在地址栏中输入url的方式只能发送 GET 请求）

3）GET 请求的参数会被完整保留在浏览器历史记录里，而 POST 请求中的参数不会被保留

4）GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制

5）GET 参数通过 URL 传递，POST 数据放在 Request body 中

6）GET 比 POST 安全性低，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息

